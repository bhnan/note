### 古典密码
1. 凯撒密码
	1. $c_i=(p_i+3)mod26$
2. 维吉尼亚密码
	1. $c_i=(p_i+k_i)mod16$

### 流密码
1. 自同步序列密码
	1. 如何实现的失步（密文丢失或者增加）只影响n位
2. m序列，一个连接多项式（即系数）使输出<mark style="background: #00C38C;">序列周期</mark>（[名词解释](专业课/名词解释.md#^pg3k6d)）达到最大值。该连接多项式叫本原多项式（[名词解释](专业课/名词解释.md#^uyc8e8)）。
3. 破解m序列
	1. 先加起来算出密钥流，创建密钥流矩阵$\begin{pmatrix}a_{1}&a_{2}&a_{3}\\a_{2}&a_{3}&a_{4}&\\a_{3}&a_{4}&a_{5}\end{pmatrix}$
	2. 然后求密钥流的逆矩阵
	3. 乘以密钥序列的下一位$(a_4,a_5,a_6)$
	4. 得出结果  
### 分组密码
1. 混淆和扩散
2. Feistel结构（[名词解释](专业课/名词解释.md#^dzyi0u)）
	1. 代替
	2. 置换
3. DES （[名词解释](专业课/名词解释.md#^gzfhlx)）
	密钥生成（[名词解释](专业课/名词解释.md#^ynveqx)）
		置换表1 去掉8位奇偶校验（[名词解释](专业课/名词解释.md#^x8xh1p)）
		循环<mark style="background: #FFF3A3A6;">左</mark>移位表（[名词解释](专业课/名词解释.md#^t0574e)）
		经过置换表2 变成48比特
	加密c=DES(p)
		初始置换
		16轮Feistel结构
			$f$函数（[名词解释](专业课/名词解释.md#^xzci0k)）
			8个s盒，输入的六位$a_1,a_2,a_3,a_4,a_5,a_6$, $a_1a_6$作为行号，$a_2a_3a_4a_5$作为列号查盒（[名词解释](专业课/名词解释.md#^r59ckp)）
		逆初始置换
	解密p=DES(c)
		子密钥顺序相反
		与加密用同一个过程
4. 两重DES
	1. 中间相遇攻击
	2. 3重DES
		1. 加密：加密k1-解密k2-加密k3
		2. 解密：解密k3-加密k2-解密k1
		3. 可以兼容DES
5. AES（[名词解释](专业课/名词解释.md#^br2ztb)）
	不是对合运算，加密解密使用不同的算法
	1. 数学基础
		1. GF(2^8)上的既约多项式为：$m(x)=x^8+x^4+x^3+x+1$，二进制值为283
		2. <mark style="background: #b8f3b8;">多项式的运算可以转换为字节的运算</mark>
		3. 字节代替
			1. 每个字节代替为它在GF($2^8$)的逆（s盒第一个16进制数为行，第二个16进制数为列）
			2.仿射变换： $b_{i}'=b_{i}\oplus b_{(i+4)mod8}\oplus b_{(i+5)mod8}\oplus b_{(i+6)mod8}\oplus b_{(i+7)mod8}\oplus c_i$[名词解释](专业课/名词解释.md#^pd8clt)
		4. 行移位
			1. 每行向右移动i行（i为行号，0开始）
		5. 列混淆
			1. 每列的字节乘多项式$c(x)=03x^3+01x^2+01x+02$ 多项式乘
			2. 再mod$x^4+1$
		6. 密钥拓展
			1. 不是整数倍，值为前一个字（32位）和前第k个字的异或
			2. 是整数倍，对前一个字进行进行字节循环左移，然后进行s盒变换，再与轮常量异或
				1. 轮常量为Rcon[j]=(Rc[j],0,0,0)
				2. Rc[j]=2*Rc[j-1]的十六进制表示
			 注：字大于6时，余数为0，4都需要进行特殊变换。
		7. 逆算法
			1. 列变换变成乘c的逆多项式$d(x)=0Bx^3+0Dx^2+09x+0E$
			2. s盒逆仿射，再逆置换
6. 加密工作模式
	1. 计算机数据的特殊性
		1. 存在明显的数据模式
		2. 短块：数据块小于分组的长度
	2. ECB（电码本）：数据块简单的进行直接加密解密，不进行关联
		1. 适用于加密密钥
	3. CBC（密文分组链接）：当前明文与前一个密文异或后再加密，第一块需要与初始向量异或
		1. 加密（[名词解释](专业课/名词解释.md#^1w0hk7)）错误会一直传下去
		2. 解密（[名词解释](专业课/名词解释.md#^c1j1o5)）错误（信道传输错误）传播有限
	4. CFB（密文反馈模式）：传输单位s位，远小于分组长度。
		1. 加密（[名词解释](专业课/名词解释.md#^sr4gek)）
		2. 解密（[名词解释](专业课/名词解释.md#^fs48z2)）
		3. 加密解密一样
		4. 错误传播无界
		5. 
	5. OFB（输出反馈模式）：与CFB类似，只是加密解过用于下一个的加密输入
		1. 加密（[名词解释](专业课/名词解释.md#^duhnjg)）
		2. 解密（[名词解释](专业课/名词解释.md#^wsqqjw)）
		3. 加密解密一样
		4. 密文篡改无法发现
	6. CTR（计数器模式）
		1. 优点：硬件效率高，可并行处理，可以预处理，随机访问，可证明安全性，简单性

### 公钥密码
1. 用途：数字签名等
2. 公钥密码工作方式
	1. 保密性
		1. 发送发：查找接收方的公钥，加密后发送给接受方
		2. 接收方：拿私钥解密
		3. <mark style="background: #b8f3b8;">不能防止人冒充发送消息</mark>
	2. 真实性
		1. 发送方：拿私钥加密，然后发送给接受方
		2. 接收方：查找发送方公钥，解密信息
	3. 双保
		1. 发送方：先拿私钥加密信息，再拿接收方公钥加密，然后发送
		2. 接收方：先拿私钥解密，在哪发送方公钥解密
3. RSA
	1. 公钥：$<e,n>$，私钥：$<p,q,d,\Phi(n)>$
	2. $n=pq,\Phi(n)=(p-1)(q-1),gcd(e,\Phi(n))=1,ed=1mod \Phi(n)$,d为e在$\Phi(n)$下的逆，e个$\Phi(n)$互素
	3. 加密：$C=P^{e} mod n$
	4. 解密：$P=C^{d} mod n$
	5. <mark style="background: #b8f3b8;">加密算法和解密算法可交换，才能实现双保</mark>
	6. Miller检验参数大素数
		1. 不通过检验，一定不是素数
		2. 通过，可能是素数
4. Robin密码体制
	1. 密钥的产生
		1. 随机选取大素数p，q；$P\equiv Q\equiv 3\mod{4}$
		2. n=pq
		3. 公钥<e=2，n> 密钥<p,q>
	2. 加密
		1. $c\equiv m^{2}\mod n$
	3. 解密
		1. 求解4个方程组$\begin{cases}x\equiv\pm y\mod{p} \\ x\equiv\pm z\mod{q}\end{cases}$
		2. 得到4个符合的明文，在明文中加入发送则的信息即可确定最终明文
	4. 特点
		1. 密文对应的明文不止一个
		2. 破解密码体制等价于大整数分解
5. ElGamal密码
	1. 使用接收方的公钥加密。
	2. 公钥$<q,a，Y_A>$大素数q，a为q的本原根，$Y_{A}=a^{X_{A}}mod q$，私钥$X_{A}$
	3. <mark style="background: #b8f3b8;">是基于计算对数困难设计的，所以保密是在指数上</mark>
	4. 任何用户可以通过<mark style="background: #FFF3A3A6;">A的公钥</mark>加密信息
		1. 随机选择k
		2. $K=(Y_{A})^{k}mod q$
		3. $C_{1}=a^{k}mod q,C_{2}=KM mod$ q
	5. A进行解密
		1. $K=(C_{1})^{X_{A}}mod q$
		2. 欧几里得算法求逆
		3. $M=(C_{2}K^{-1})mod q$
	6. 优点
		1. 素数比RSA小，加解密速度快
	7. <mark style="background: #FFF3A3A6;">缺陷</mark>：分块加密时，每块需用不同k；可以亚指数
6. Diffie-Hellman密钥协议
	1. 密钥交换
	2. 中间人攻击
7. 椭圆曲线加密ECC
	1. 素数域上的椭圆曲线
		1. 椭圆曲线的所有解（即点）构成加法循环群（[名词解释](专业课/名词解释.md#^get8zu)）
		2. 定义：
			1. 0元素为零元，表示无穷点
			2. $P+0=P$，P为任一点
			3. $P+Q=0$，$P=(x_{p},y_{p}),Q=(x_{p},-q_{p})$,$Q$为$P$的逆元
			4. $R=P+Q=(x_{R},y_{R})$
				1. $x_{R}=(\lambda^{2-x_{P}-x_{Q})mod}p$
				2. $y_{R}=(\lambda(x_{P}-x_{R})-y_{P})mod p$
				3. $\lambda=\begin{cases}(\frac{y_{Q}-y_{P}}{x_{Q}-x_{P}})modp &P\ne Q \\ (\frac{3x_{p}^{2}+a}{2y_{P}})modp &P=Q\end{cases}$，$a$为椭圆曲线的系数
			5. 乘法转化为重复加法
		3. 优点：密钥短，运算速度较快，实现复杂
	2. 椭圆曲线密码的基础参数
		1. $<p,a,b,G,n,h>$
		2. G是生成元，G的阶必须为非常大的素数
	3. 密钥
		1. 私钥是$d\in\{1,2,...,n-1\}$
		2. 公钥为$P=d*G$
	4. 加密过程
		1. 产生随机数k
		2. $X_1(x_1,y_1)=kG$
		3. $X_2(x_2,y_2)=kQ$，如果$x_2=0，则重选k
		4. 计算密文：$C=Mx_{2}modn$
		5. 最终密文为$(X_1,C)$
	5. 解密过程
		1. $\begin{align*}dX_{1}&=d(kG) \\ &=k(dG) \\ &=kQ \\ &=X_{2}(x_2,y_2)\end{align*}$
		2. $M=Cx_{2}^{-1}mod n$
	6. 难点
		1. 椭圆曲线如何产生
		2. 倍点运算计算困难
### 哈希函数
1. 应用：消息认证；数字签名；
2. 要求：
	1. 任意长输入，定长输出。
	2. 容易计算。
	3. 单向性：已知x，求y=H(x)简单，已知y，求满足y=H(x)的x很难。<mark style="background: #FF0000;">和压缩的区别。</mark>
	4. 抗弱碰撞：即防篡改，找到与x相同哈希的$x_1$，在计算上不可行。
	5. 抗强碰撞：<mark style="background: #FF0000;">任意</mark>x，y的哈希值都不相同。生日悖论（攻击者想办法让A进行签名。）
3. 具有错误检测能力。
4. 安全性取决于是否抗碰撞攻击，是否单向。
5. 各种应用对哈希函数的要求（[名词解释](专业课/名词解释.md#^e37kob)）
6. MD5
	1. 增加填充位，空余64位用来填充长度
	2. 填充长度
	3. 初始化缓存区
	4. 以512位分组处理消息（压缩函数-[名词解释](专业课/名词解释.md#^yt0gm1)）
		1. 16步迭代（[名词解释](专业课/名词解释.md#^iaw6wh)）
		2. g函数（[名词解释](专业课/名词解释.md#^4mou8m)）
	6. 输出128位
7. SHA
	1. 步骤
		1. 附加填充位
			1. 填充时，要保留附加长度块的字节，正好满足也许添加一个分组的大小的块
		2. 附加长度
			1. 填充前的消息长度
		3. 初始化hash缓冲区
			1. 把缓存寄存器初始化位<mark style="background: #FF0000;">对应的值</mark>
				1. 3. SHA-1为5个32位寄存器（[名词解释](专业课/名词解释.md#^ignqsb)）。
				2. SHA-512的缓冲区为8个64位寄存器，值为前8个素数的平方根去前64比特。
		4. 处理消息
			1. SHA-1的函数（[名词解释](专业课/名词解释.md#^5jv9an)）
				1. f函数（[名词解释](专业课/名词解释.md#^8t6clx)）
				2. $w_i$：（[名词解释](专业课/名词解释.md#^92b5zm)）$m_i$为每轮512为数据的分块，分为16块
				3. $k_i$为常数
			2. SHA-512函数（[名词解释](专业课/名词解释.md#^lz87t7)）
				1. 基础函数（[名词解释](专业课/名词解释.md#^0mvag7)）
				2. $k_i$（[名词解释](专业课/名词解释.md#^xum8ua)）
				3. $w_i$（[名词解释](专业课/名词解释.md#^1rfnzf)）
		5. 输出
### 认证
1. 鉴别，认证
2. 加密是保密性；认证是真实性，完整性；
3. 认证是双方验证；签名是所有人都可以验证。
4. 口令：要求是单向函数，不需要解密。一般为哈希函数
5. CBC-MAC（[名词解释](专业课/名词解释.md#^20tmp8)）
6. HMAC（[名词解释](专业课/名词解释.md#^ucw0sp)）
	1. k如果大于b字节就使用hash函数压缩到b字节
	2. k如果小于b字节就左边填充0到b字节
### 数字签名
1. 特性：不可伪造：B无法伪造一个消息而声称是A发出的。不可抵赖：A不能声称一个已发出的消息不是自己发出的。不可复制：消息无法重放通过认证。
2. RSA数字签名体制
	1. 简单的对消息进行加密。
		1. 签名：$s=m^{d}mod n$，d为私钥
		2. 验证：$m=s^{e}mod n$，<e，n>为公钥
	2. 缺陷
		1. 任何人都可以伪造$x=y^{e}modn$，$x$是A的签名
		2. 可以伪造：$(m_{1}m_{2})^{d}=m_{1}^{d}m_{2}^{d}modn$
		3. 长度越长签名越慢。
	4. 解决方法：先hash再加密
		1. 签名：$S=hash(m)^{d}mod n$
		2. 验证：$hash(m)=S^{e}mod n$
3. ElGamal数字签名
	1. 实现
		1. 签名：g为本原根，选择x作为密钥，生成$y=g^xmodp$作为公钥。公开p和g。<br>随机选择k，k需要与（p-1）互素。<br>$r=g^kmodp$<br>$s=(m-xr)k^{-1}mod(p-1)$<br>将（m,r,s）发送。
		2. 验证：$\because s=(m-rx)k^{-1}mod (p-1),\therefore m=xr+ksmod(p-1)$，所以$g^{m}modp=g^{xr+ks}=(g^{x})^{r}(g^k)^{s}=y^{r}r^{s}modp$
4. Schnorr数字签名
	1. 生成公钥私钥<br>选择大素数p,q。且q是p-1的素因子。<br>选择整数$\alpha$，$\alpha^q=1modp$。$\alpha,p,q$是全局公钥参数。<br>随机选取整数s，作为私钥。<br>计算$v=\alpha^smodp$作为公钥
	2. 签名<br>随机选择整数r，计算$x=\alpha^rmodp$<br>$e=H(M||x)$<br>计算$y=(r+se)modq$，签名为$<e,y>$
	3. 验证<br>$x'=\alpha^{y}v^{-e}=\alpha^{y}\alpha^{-es}=\alpha^r=xmodp$<br>验证$e=H(M||x')$
5. DSA签名体制
	1. 生成公钥私钥<br>选择大素数p，以及q。且q是p-1的素因子。<br>$g=h^{\frac{p-1}{q}}modp$<br>随机选择私钥x<br>计算$y=g^xmodp$作为公钥
	2. 签名<br>随机产生k，每轮不一样<br>$r=(g^{k}modp)modq,s=[k^{-1}(H(M)+xr)]modq$，H(M)为SHA<br>签名为<r,s>
	3. 验证<br>$w=s^{-1}modq$<br>$u_1=[H(M')w]modq$<br>$u_{2}=(r)wmodq$<br>$v=[(g^{u_{1}}y^{u_{2}})modp]modq$<br>验证v是否等于r
### 安全协议
1. 基于对称加密的密钥分发
	1. 无KDC（[名词解释](专业课/名词解释.md#^7029th)）
		1. A向B发出建立会话密钥请求和一个一次性随机数N1
		2. B使用主密钥对（会话密钥，A的ID，B的ID，f（N1），N2）进行加密
		3. A解密后保存会话密钥，并使用会话密钥将f（N2）返回给B
	2. 有KDC（[名词解释](专业课/名词解释.md#^f856ds)）
		1. A向KDC发送请求（A的id，B的id，会话唯一标识符N1）
		2. KDC发送两个消息，（会话密钥，A的id，B的id，标识符N1）然后用A的密钥加密，（会话密钥，A的id）用B的密钥加密。
		3. A把第二个消息转发给B
		4. B使用会话密钥加密会话标识符N2
		5. A把f（N2）加密后返回给B
2. 基于非对称的加密的密钥分发
	1. 公钥授权（[名词解释](专业课/名词解释.md#^wapumc)）
		1. 向公钥授权机构发送一个请求，包含时间戳，为了获取B的公钥。
		2. 公钥管理机构返回拿私钥加密的消息（B的公钥，A发送的请求和时间戳）防止重放
		3. A发送B公钥加密的消息（A的id，会话标识符N1）给B
		4. B向授权机构发送获取A公钥的请求（同1）
		5. 授权机构返回消息（同2）
		6. B发送消息（N1，N2）使用A的公钥加密
		7. A返回加密消息E（B的公钥，N2）给B
3. X.509（[名词解释](专业课/名词解释.md#^okfw94)）
	1. 不同证书机构之间的证书传递
		1. A获取B的证书
		2. $X<W>W<V>V<Y>Y<Z>Z<B>$
	2. X.509认证过程 #遗留
4. Kerberos协议
	1. 目标
		1. 在分布式网络中，客户端与服务端的授权问题
	2. 认证服务器AS
		1. 对客户的身份进行认证
	3. 票据服务器TGS
		1. 为了解决口令需要用户重复输入
		2. 口令是明文传输
	4. 工作流程（[名词解释](专业课/名词解释.md#^f23fqe)）
		1. 用户请求主机服务
		2. 认证服务器验证用户访问权，创建授权票据和会话密钥，使用用户密钥加密后返回给用户
		3. 用户端输入密码解密消息，发送票据和包含应虎门，网络地址和时间的认证码给票据服务器
		4. 票据服务器解密，验证后，产生服务器票据
		5. 客户端发送授权票据和认证码给服务器
		6. 服务器验证后，授权服务。
		7. <mark style="background: #FFF3A3A6;">每个用户只需要和认证服务器通信一次（1，2），每类服务器仅需要从票据服务器获取一个票据（3，4），每次和服务器的服务会话（5，6）仅一次</mark>
