* m序列的破译
	先把明文流和密文流异或得到密钥流
	建立方程$(a_{t+1},a_{t+2},\cdots,a_{t+t}=(c_{t},c^t-1,\cdots,c_{1})\begin{pmatrix}a_{1}&a_{2}&\cdots&a_{t} \\ a_{2}&a_{3}&\cdots&a_{t+1} \\ \vdots&\vdots&&\vdots \\ a_{t}&a_{t+1}&\cdots&a_{t+t-1}\end{pmatrix}$
	$c=aA^{-1}$
	密钥流递推关系为$a_{t+i}=c_{t}a_{i}\bigoplus c_{t-1}a^{i+1}\bigoplus\cdots\bigoplus c_{1}a_{i+t-1}$
例题：![](附件/Pasted%20image%2020221012203339.png)
![](附件/Pasted%20image%2020221012203348.png)
#m序列破译

---
#群
群需要满足封闭性，结合律，单位元，逆元

---
#加密信息攻击类型 
唯密文攻击：只有密文
已知明文攻击：知道多个明密文对
选择明文攻击：可以选择明文，并且能得到对应密文
选择密文攻击：可以选择密文，并且得到对应的明文

---
#古典密码
代替：讲明文中的元素映射成另一个
置换：将明文中的元素重新排列

---
#签名
盲签名：

---
#费马定理 
$a^{p-1}\equiv 1(mod p)$p是素数

---
#欧几里得算法
若a与p互素，$a*x\mod p=1$,x为a的逆元
$k*p+1\mod{p}=1$，$\therefore a*x=k*p+1$，也就是$a*x+k*p=1$

---
#弱密钥
产生的子密钥没有全部不同
子密钥全部相同 弱密钥4个
存在两个子密钥 半弱密钥
存在4个子密钥 四分之一弱密钥
存在8个子密钥 八分之一弱密钥

---
#OFB和CFB的错误传播
OFB没有错误传播。
CFB有错误传播，明文发生错误，密文都会受到影响，但解密后，处理原来有错的一组，其他明文都能恢复。

---
#雪崩效应
输入发生了微小的变化（一个二进制位的反转），导致不可区分的输出改变。
哈希和块密码的理想属性

---
#公钥密码的最小密钥长度
RSA 1024位
ElGamal 1024位
ECC 160位

---
kmc：密钥管理机构
kdc：密钥分发机构
密码设计的基本方法：扩散，混淆，迭代
密钥分配过程要求秘密性，真实性，完整性。
<mark style="background: #FFF3A3A6;">传统密码可以提供认证</mark>

---
仿射密码：再简单的取余之前，先对明文乘一个常数
加密：$c=E(m)=am+b(\mod26)$
解密：$m=D(c)=(c-b)a^{-1}(\mod{26})$

Hill密码：密钥是矩阵
加密：$(c_1,c_2,c_3)=(p_1,p_2,p_3)\begin{bmatrix}k_{11}&k_{12}&k_{13} \\ k_{21}&k_{22}&k_{23} \\ k_{31}&k_{32}&k_{33}\end{bmatrix}\mod{26};C=PK\mod{26}$
解密：$P=CK^{-1}\mod{26}$

Playfair密码：把密钥词去掉重复后，配合上剩余的字母从左到右，从上到下填充成一个5乘5的矩阵（I和J算一个），两个字母当成一个单元进行替换。
1. 如果字母相同，中间填充一个字母
2. 如果字母在同一行，则拿右边字母替换
3. 如果字母在同一列，则拿下面字母替换
4. 剩下情况，构成矩阵的另一对角，行行对应
